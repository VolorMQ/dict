<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>FlashDialogs</title>
<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
<style>
/* ===== –û–°–ù–û–í–ê ===== */
body {
  margin: 0; 
  padding: 0;
  font-family: 'Comic Neue', cursive;
  min-height: 100vh; 
  overflow: hidden;
  position: relative;

  /* üé® –¢—ë–º–Ω—ã–π –ø–∞—Å—Ç–µ–ª—å–Ω—ã–π —Ñ–æ–Ω */
  background: linear-gradient(
    135deg,
    #2e1a3f,
    #3a1f2c,
    #1f2a3a,
    #1f3a2c,
    #3a1f1f
  );
  background-size: 1200% 1200%;
  animation: darkPastelBG 90s ease infinite, brightnessPulse 60s ease-in-out infinite;
}

/* –ø–ª–∞–≤–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç */
@keyframes darkPastelBG {
  0%   { background-position: 0% 50%; }
  25%  { background-position: 50% 100%; }
  50%  { background-position: 100% 50%; }
  75%  { background-position: 50% 0%; }
  100% { background-position: 0% 50%; }
}

@keyframes brightnessPulse {
  0%   { filter: brightness(0.85); }
  50%  { filter: brightness(1.0); }
  100% { filter: brightness(0.85); }
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background: radial-gradient(
    ellipse at 30% 30%, 
    rgba(255,255,255,0.05), 
    rgba(0,0,0,0.3)
  );
  animation: lightBreath 70s ease-in-out infinite;
  z-index: 0;
}

@keyframes lightBreath {
  0%   { opacity: 0.2; }
  50%  { opacity: 0.3; }
  100% { opacity: 0.2; }
}

/* ===== –õ–ï–¢–ê–Æ–©–ò–ï –°–õ–û–í–ê ===== */
.particle {
  position: absolute;
  font-weight: bold;
  text-align: center;
  pointer-events: none;
  user-select: none;
  font-size: clamp(2rem, 6vw, 4rem);
  background: linear-gradient(45deg, #ff9a9e,#fad0c4,#ffd700,#6fd6ff,#ff6f61);
  background-size: 400% 400%;
  animation: gradientText 5s ease infinite;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow:0 0 10px rgba(0,0,0,0.6);
  transition:left 3s ease, top 3s ease;
  padding: 18px;
  border-radius: 12px;
  z-index: 10;
}

/* —Ç–æ–∫–µ–Ω—ã –¥–∞—Ç—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ (–ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é –±–µ—Ä—É—Ç –≥—Ä–∞–¥–∏–µ–Ω—Ç —Ä–æ–¥–∏—Ç–µ–ª—è) */
.da-token {
  display: inline-block;
  white-space: pre;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  transition: transform 120ms ease, text-shadow 120ms ease;
}

/* –ø–æ–¥—Å–≤–µ—Ç–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–ª–æ–≤–∞ (–¥–∞—Ç—Å–∫–∏–π) */
.da-token.highlight {
  -webkit-text-fill-color: #ffffff !important;
  color: #ffffff !important;
  -webkit-background-clip: initial !important;
  background: none !important;
  transform: translateY(-3px) scale(1.05);
  text-shadow: 0 0 14px rgba(255,215,0,0.95), 0 0 6px rgba(0,0,0,0.6);
  border-radius: 6px;
  padding: 2px 6px;
}

/* –º–∞–ª–µ–Ω—å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –ø–æ–¥ –¥–∞—Ç—Å–∫–∏–º —Ç–µ–∫—Å—Ç */
.translation {
  display:block;
  font-size:0.5em;
  margin-top:0.2em;
  color:#fff;
  text-shadow:0 0 6px rgba(0,0,0,0.9);
}

/* ===== –¶–ï–ù–¢–†–ê–õ–¨–ù–´–ï –ö–û–ù–¢–†–û–õ–´ ===== */
#controls {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  flex-wrap: nowrap;
  z-index: 100;
}

/* ===== –ü–ê–ù–ï–õ–¨ –ó–ê–ì–†–£–ó–ö–ò –§–ê–ô–õ–ê –†–Ø–î–û–ú –° –ö–ù–û–ü–ö–ê–ú–ò ===== */
#dictionaryControls {
  position: fixed;
  bottom: 12px;
  left: calc(50% + 180px);
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
  z-index: 100;
  font-size: 0.85rem;
  color: #fff;
}

/* –ö–Ω–æ–ø–∫–∏ –∏ input */
#controls button,
#dictionaryControls button,
#dictionaryControls input {
  background: rgba(0,0,0,0.45);
  border: none;
  border-radius: 12px;
  padding: 8px 14px;
  color: #fff;
  font-size: 1rem;
  outline: none;
  text-align: center;
  white-space: nowrap;
}
#controls button:hover,
#dictionaryControls button:hover {
  background: rgba(0,0,0,0.65);
  cursor: pointer;
}

#controls input {
  background: rgba(0,0,0,0.45);
  border: none;
  border-radius: 12px;
  padding: 8px 10px;
  color: #fff;
  font-size: 1rem;
  outline: none;
  text-align: center;
  width: 140px;
}
#controls input::placeholder { color: #bbb; }

@media (max-width: 600px) {
  #controls { flex-wrap: wrap; justify-content: center; bottom: 72px; }
  #controls input { width: 120px; }
  #dictionaryControls { bottom: 96px; left: 50%; transform: translateX(-50%); }
}
@media (max-width: 420px) {
  #controls input { width: 100px; }
  #controls button,#dictionaryControls button,#dictionaryControls input { padding:6px 10px; font-size:0.9rem; }
}
@media (max-width: 360px) {
  #controls { bottom: 96px; }
  #dictionaryControls { bottom: 72px; left: 6px; gap:4px; font-size:0.8rem; }
}

#controls,
#dictionaryControls { visibility: visible; }

</style>
</head>
<body>

<div id="particleContainer" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>

<!-- –ü–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
<div id="controls">
  <input id="stepInput" type="number" min="1" value="1" placeholder="N">
  <button id="stepBtn">OK</button>
  <button id="startBtn">–°—Ç–∞—Ä—Ç</button>
  <button id="stopBtn">–°—Ç–æ–ø</button>
</div>

<div id="dictionaryControls">
  <label><input type="file" id="localFileInput" accept=".json" style="width:90px"></label>
</div>

<script>
const MAX_REPEATS = 3; // –ø–æ–≤—Ç–æ—Ä—è–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ
let dialogs = [];
let currentIndex = 0; // —Ç–µ–∫—É—â–∏–π –¥–∏–∞–ª–æ–≥
let stepN = 1;        // —à–∞–≥ –ø–æ –¥–∏–∞–ª–æ–≥–∞–º
let showingSentence = false;
let sessionRunning = false;
let sessionStarted = false;
let sentenceIndex = 0; // —Ç–µ–∫—É—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤ –¥–∏–∞–ª–æ–≥–µ

const PAUSE_MS_PER_SIGN = 50;

// ---------- TTS ----------

function cleanTextForTTS(text) {
  return text.replace(/[^a-zA-Z–∞-—è—ë–ê-–Ø–Å√¶√∏√•√Ü√ò√Ö\s,.!?;:‚Äî‚Äì¬´¬ª'"]/g,'').trim();
}

function speak(text, lang, rate=1){
  return new Promise(resolve=>{
    const u = new SpeechSynthesisUtterance(cleanTextForTTS(text));
    u.lang = lang;
    u.rate = rate;
    u.onend = resolve;
    speechSynthesis.speak(u);
  });
}

// ---------- –î–∞—Ç—Å–∫–∏–π –≥–æ–ª–æ—Å —Å —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ–º ----------
let daVoices = [];
let lastDaVoice = 0; // –¥–ª—è —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏—è

function initVoices() {
  daVoices = speechSynthesis.getVoices().filter(v => v.lang && v.lang.startsWith("da"));
  if(daVoices.length < 2){
    console.warn("–ú–µ–Ω—å—à–µ –¥–≤—É—Ö –¥–∞—Ç—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤, –±—É–¥—É—Ç –ø–æ–≤—Ç–æ—Ä—è—Ç—å—Å—è");
  }
}

speechSynthesis.onvoiceschanged = initVoices;
initVoices();

async function speakDaSimple(text, rate=1){
  if(daVoices.length === 0) return speak(text, "da-DK", rate); // fallback
  const voice = daVoices[lastDaVoice % daVoices.length];
  lastDaVoice = (lastDaVoice + 1) % daVoices.length;
  return new Promise(resolve=>{
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "da-DK";
    u.voice = voice;
    u.rate = rate;
    u.onend = resolve;
    speechSynthesis.speak(u);
  });
}

// ---------- –¢–æ–∫–µ–Ω–∏–∑–∞—Ü–∏—è (—Å–ª–æ–≤–∞ / –ø—É–Ω–∫—Ç—ã / –ø—Ä–æ–±–µ–ª—ã) ----------
function tokenizePreserve(text){
  // –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Å–ª–æ–≤–∞ (–ª–∞—Ç–∏–Ω—Å–∫–∏–µ –∏ —Å–∫–∞–Ω–¥–∏–Ω–∞–≤—Å–∫–∏–µ –±—É–∫–≤—ã), –≤—Å—ë –ø—Ä–æ—á–µ–µ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã, –∏ –ø—Ä–æ–±–µ–ª—ã –æ—Ç–¥–µ–ª—å–Ω–æ
  const re = /[A-Za-z√Ü√ò√Ö√¶√∏√•√Ä-√ñ√ò-√∂√∏-√ø]+|[^\sA-Za-z√Ü√ò√Ö√¶√∏√•√Ä-√ñ√ò-√∂√∏-√ø]+|\s+/g;
  const raw = text.match(re) || [];
  return raw.map(t => ({ text: t, isWord: /[A-Za-z√Ü√ò√Ö√¶√∏√•√Ä-√ñ√ò-√∂√∏-√ø]/.test(t) }));
}

function escapeHtml(s){
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ---------- –ù–æ–≤—ã–π –º–µ—Ç–æ–¥: –≥–æ–≤–æ—Ä–∏–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–ª–∏–∫–æ–º –∏ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Å–ª–æ–≤–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ ----------
// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç SpeechSynthesisUtterance.onboundary, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ.
// –í fallback ‚Äî –ø—Ä–∏–±–ª–∏–∂—ë–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Å–ª–æ–≤–æ.
function speakWithHighlight(fullText, lang, rate=1, isDa=false, highlightCallback=null){
  return new Promise(resolve => {
    if(!fullText || !fullText.trim()) { resolve(); return; }

    const tokens = tokenizePreserve(fullText);
    // —Å–æ–∑–¥–∞—ë–º –º–∞—Å—Å–∏–≤ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ —Ç–æ–ª—å–∫–æ –¥–ª—è "—Å–ª–æ–≤" —Å –ø–æ—Ä—è–¥–∫–æ–≤—ã–º wordIndex
    let pos = 0;
    const wordRanges = [];
    let wordCounter = 0;
    tokens.forEach(tok => {
      const len = tok.text.length;
      const start = pos;
      const end = pos + len; // exclusive
      if(tok.isWord){
        wordRanges.push({ start, end, wordIndex: wordCounter });
        wordCounter++;
      }
      pos = end;
    });

    // –≤—ã–±–∏—Ä–∞–µ–º –≥–æ–ª–æ—Å (–¥–ª—è –¥–∞—Ç—Å–∫–æ–≥–æ) –∏–ª–∏ fallback
    let voice = null;
    if(isDa && daVoices.length > 0){
      voice = daVoices[lastDaVoice % daVoices.length];
      lastDaVoice = (lastDaVoice + 1) % daVoices.length;
    }

    const utterText = fullText; // –Ω–µ —á–∏—Å—Ç–∏–º —Å–∏–ª—å–Ω–æ ‚Äî —Ö–æ—Ç–∏–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã —Å–∏–º–≤–æ–ª–æ–≤
    const u = new SpeechSynthesisUtterance(utterText);
    u.lang = isDa ? "da-DK" : lang;
    if(voice) u.voice = voice;
    u.rate = rate;

    // —Ñ—É–Ω–∫—Ü–∏—è –∫–æ—Ç–æ—Ä–∞—è –ø–æ charIndex –≤—ã—á–∏—Å–ª—è–µ—Ç wordIndex –∏ –≤—ã–∑—ã–≤–∞–µ—Ç highlightCallback
    function handleCharIndex(charIndex){
      if(typeof highlightCallback !== 'function') return;
      if(charIndex == null) { highlightCallback(null); return; }
      // –Ω–∞–π—Ç–∏ wordRanges, –≥–¥–µ charIndex –ø–æ–ø–∞–¥–∞–µ—Ç –≤ [start, end)
      const match = wordRanges.find(w => charIndex >= w.start && charIndex < w.end);
      if(match) highlightCallback(match.wordIndex);
    }

    // –µ—Å–ª–∏ –±—Ä–∞—É–∑–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onboundary ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
    let usedBoundary = false;
    u.onboundary = (ev) => {
      // –≤ Chrome/Edge/Firefox –∏–Ω–æ–≥–¥–∞ ev.name === 'word' –∏–ª–∏ ev.charIndex –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç
      const ci = ev.charIndex;
      if(ci != null){
        usedBoundary = true;
        handleCharIndex(ci);
      }
    };

    // –æ—á–∏—Å—Ç–∫–∞ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –≤ –∫–æ–Ω—Ü–µ
    u.onend = () => {
      if(typeof highlightCallback === 'function') highlightCallback(null);
      resolve();
    };

    // –ï—Å–ª–∏ onboundary –≤–æ–æ–±—â–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç (—á–∞—Å—Ç—ã–µ —Å–ª—É—á–∞–∏ –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–∞—Ö),
    // –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback: –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ —Å–ª–æ–≤–∞–º.
    // –î–ª—è —ç—Ç–æ–≥–æ —Å—Ç–∞—Ä—Ç—É–µ–º —Ç–∞–π–º–µ—Ä –æ–∂–∏–¥–∞–Ω–∏—è –Ω–∞—á–∞–ª–∞ –∏ –∑–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä–∏–º, —Å—Ä–∞–±–æ—Ç–∞–ª –ª–∏ onboundary.
    let boundaryDetected = false;
    const boundaryProbeTimeout = setTimeout(() => {
      if(usedBoundary) { boundaryDetected = true; return; }
      // fallback logic
      const wordsCount = wordRanges.length || 1;
      // —Å—Ä–µ–¥–Ω—è—è —Å–∫–æ—Ä–æ—Å—Ç—å ~ 180 —Å–ª–æ–≤/–º–∏–Ω ~ 3 —Å–ª–æ–≤/—Å–µ–∫ –ø—Ä–∏ rate=1
      const wordsPerSec = 3 * rate;
      const estimatedTotalSec = Math.max(0.6, wordsCount / wordsPerSec);
      // —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏–º –≤—Ä–µ–º–µ–Ω–∞ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –¥–ª–∏–Ω–µ —Å–ª–æ–≤–∞ –≤ —Å–∏–º–≤–æ–ª–∞—Ö
      const lengths = wordRanges.map(w => (w.end - w.start));
      const totalChars = lengths.reduce((a,b)=>a+b,0) || 1;
      let acc = 0;
      wordRanges.forEach((w, idx) => {
        acc += lengths[idx];
        const t = (acc / totalChars) * estimatedTotalSec * 1000;
        setTimeout(() => {
          if(typeof highlightCallback === 'function') highlightCallback(w.wordIndex);
        }, t);
      });
      // —Å–Ω—è—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∫—É –≤ –∫–æ–Ω—Ü–µ
      setTimeout(() => {
        if(typeof highlightCallback === 'function') highlightCallback(null);
      }, estimatedTotalSec*1000 + 50);
    }, 120); // –ø–æ–¥–æ–∂–¥—ë–º 120ms, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –Ω–∞—á–Ω—ë—Ç –ª–∏ —Ä–∞–±–æ—Ç–∞—Ç—å onboundary

    // –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ ‚Äî –æ—á–∏—Å—Ç–∏–º probe
    u.onend = () => {
      clearTimeout(boundaryProbeTimeout);
      if(typeof highlightCallback === 'function') highlightCallback(null);
      resolve();
    };

    speechSynthesis.speak(u);
  });
}

// ===== UI –ø–æ–∑–∏—Ü–∏–∏ =====
function randomPosition(el){
  const topOffset = 12;
  const bottomControls = document.getElementById('controls');
  const bottomMenu = document.getElementById('dictionaryControls');
  const bottomLimit = Math.max(bottomControls.offsetHeight,bottomMenu.offsetHeight)+12;
  const containerHeight = window.innerHeight - el.offsetHeight - bottomLimit - topOffset;
  return { x: Math.random()*(window.innerWidth-el.offsetWidth), y: topOffset+Math.random()*Math.max(0,containerHeight) };
}

function moveTo(el,pos){ el.style.left=pos.x+'px'; el.style.top=pos.y+'px'; }

// ===== –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–¥–Ω–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π –¥–∞—Ç—Å–∫–∏—Ö —Å–ª–æ–≤ =====
async function showSentence(sentence){
  showingSentence = true;
  const el = document.createElement('div');
  el.className = 'particle';
  el.style.position = 'absolute';

  // –†–∞–∑–±–∏–≤–∞–µ–º –¥–∞—Ç—Å–∫–∏–π —Ç–µ–∫—Å—Ç –Ω–∞ —Ç–æ–∫–µ–Ω—ã –∏ –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ span'—ã
  const tokens = tokenizePreserve(sentence.danish);
  let wordCounter = 0;
  const partsHtml = tokens.map(t => {
    if(t.isWord){
      const html = `<span class="da-token" data-word-index="${wordCounter}">${escapeHtml(t.text)}</span>`;
      wordCounter++;
      return html;
    } else {
      return `<span class="da-token" data-word-index="-">${escapeHtml(t.text)}</span>`;
    }
  }).join('');

  el.innerHTML = `${partsHtml}<span class="translation">${escapeHtml(sentence.translation)}</span>`;
  document.getElementById('particleContainer').appendChild(el);
  moveTo(el, randomPosition(el));

  const tokenSpans = Array.from(el.querySelectorAll('.da-token'));
  function highlightWord(idx){
    tokenSpans.forEach(s => s.classList.remove('highlight'));
    if(idx === null || idx === undefined) return;
    const target = tokenSpans.find(s => s.dataset.wordIndex === String(idx));
    if(target) target.classList.add('highlight');
  }

  // —Å–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–≤–æ–¥ (—Ä—É—Å—Å–∫–∏–π) ‚Äî –±–µ–∑ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
  await speak(sentence.translation, 'ru-RU');

  // —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–æ–≤—Ç–æ—Ä–æ–≤: –º–µ–¥–ª–µ–Ω–Ω–æ, –±—ã—Å—Ç—Ä–µ–µ, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ
  const rates = [0.3, 0.6, 1.0];

  // —Ç—Ä–∏ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
  for(let i=0; i<MAX_REPEATS; i++){
    if(!sessionRunning) break;
    if(i>0) await new Promise(r=>setTimeout(r, 1500));
    moveTo(el, randomPosition(el));

    await new Promise(resolve => {
      const u = new SpeechSynthesisUtterance(sentence.danish);
      u.lang = 'da-DK';
      u.rate = rates[Math.min(i, rates.length-1)];
      if(daVoices.length>0) u.voice = daVoices[lastDaVoice % daVoices.length];
      lastDaVoice++;

      // –ø–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–ª–æ–≤ —á–µ—Ä–µ–∑ onboundary
      u.onboundary = ev => {
        if(ev.charIndex != null){
          let pos = 0;
          for(let w=0, idx=0; idx<tokens.length; idx++){
            const t = tokens[idx];
            const len = t.text.length;
            if(t.isWord){
              if(ev.charIndex >= pos && ev.charIndex < pos+len){
                highlightWord(w);
                break;
              }
              w++;
            }
            pos += len;
          }
        }
      };

      u.onend = () => {
        highlightWord(null);
        resolve();
      };

      speechSynthesis.speak(u);
    });
  }

  el.remove();
  showingSentence = false;
}



// ===== –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ —Å –æ–∑–≤—É—á–∫–æ–π –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ –±–ª–æ–∫–∞ =====
async function showDialog(dialog){
  const sentences = dialog.dialog;

  // ==== –ù–ê–ß–ê–õ–û –ë–õ–û–ö–ê ====
  await speak(`–ù–∞—á–∞–ª–æ –¥–∏–∞–ª–æ–≥–∞ ${currentIndex+1}`, "ru-RU");

  for(sentenceIndex=0; sentenceIndex<sentences.length; sentenceIndex++){
    // –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª –°—Ç–æ–ø ‚Äî –ø—Ä–µ—Ä–≤—ë–º –ø—Ä–æ–≥–æ–Ω
    if(!sessionRunning) break;
    await showSentence(sentences[sentenceIndex]);
  }

  // ==== –ö–û–ù–ï–¶ –ë–õ–û–ö–ê ====
  await speak(`–ö–æ–Ω–µ—Ü –¥–∏–∞–ª–æ–≥–∞ ${currentIndex+1}`, "ru-RU");

  sentenceIndex = 0;
  currentIndex = (currentIndex + stepN) % dialogs.length; // —Å–ª–µ–¥—É—é—â–∏–π –¥–∏–∞–ª–æ–≥
}

// ===== START/STOP =====
document.getElementById('startBtn').addEventListener('click', ()=>{
  sessionRunning = true;
  if(!sessionStarted){ sessionStarted = true; startSession(); }
});
document.getElementById('stopBtn').addEventListener('click', ()=>{
  sessionRunning = false;
  // –æ—Å—Ç–∞–Ω–æ–≤–∏–º —Ç–µ–∫—É—â—É—é –æ–∑–≤—É—á–∫—É –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
  try { speechSynthesis.cancel(); } catch(e){}
});

// –∏–∑–º–µ–Ω–µ–Ω–∏–µ —à–∞–≥–∞
document.getElementById('stepBtn').addEventListener('click', ()=>{
  const v = parseInt(document.getElementById('stepInput').value, 10);
  if(!isNaN(v) && v>0) stepN = v;
});

// ===== LOAD FILE =====
document.getElementById('localFileInput').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = event=>{
    try{
      const data = JSON.parse(event.target.result);
      dialogs = data.map(d => {
        const key = Object.keys(d)[0]; // dialog0, dialog1, ...
        return { dialog: d[key] };
      });
      currentIndex = 0; showingSentence = false;
      console.log("–î–∏–∞–ª–æ–≥–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã:", file.name);
    }catch(err){
      console.error("–û—à–∏–±–∫–∞:", err);
      alert("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç JSON");
    }
  };
  reader.readAsText(file);
});

// ===== LOAD DEFAULT DICTIONARY =====
function loadDictionary(file){
  fetch(file)
    .then(r => r.json())
    .then(data => {
      dialogs = data.map(d => {
        const key = Object.keys(d)[0];
        return { dialog: d[key] };
      });
      currentIndex = 0; showingSentence = false;
      console.log("–î–∏–∞–ª–æ–≥–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã —Å —Å–µ—Ä–≤–µ—Ä–∞:", file);
    })
    .catch(err => console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–æ–≤–∞—Ä—è:", err));
}

// ===== SESSION LOOP =====
async function startSession(){
  while(true){
    if(sessionRunning && dialogs.length>0){
      await showDialog(dialogs[currentIndex]);
    } else await new Promise(r=>setTimeout(r,500));
  }
}

loadDictionary('dialogs.json');

window.addEventListener('load', ()=>{
  const controls = document.getElementById('controls'),
        dict = document.getElementById('dictionaryControls');
  controls.offsetHeight; dict.offsetHeight;
  controls.style.visibility = 'visible';
  dict.style.visibility = 'visible';
});

</script>

</body>
</html>
