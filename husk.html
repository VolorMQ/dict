<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flashwords</title>

<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">

<style>
body {
  margin: 0;
  padding: 0;
  font-family: 'Comic Neue', cursive;
  min-height: 100vh;
  overflow: hidden;
  background: linear-gradient(270deg, #1a1a2e, #23233a, #2b2b44, #1f1c2c);
  background-size: 800% 800%;
  animation: gradientBG 70s ease infinite;
}

@keyframes gradientBG {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.particle {
  position: absolute;
  font-weight: bold;
  text-align: center;
  pointer-events: none;
  user-select: none;
  font-size: clamp(2rem, 6vw, 4rem);
  background: linear-gradient(45deg, #ff9a9e, #fad0c4, #ffd700, #6fd6ff, #ff6f61);
  background-size: 400% 400%;
  animation: gradientText 5s ease infinite;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 10px rgba(0,0,0,0.6);
  transition: left 3s ease, top 3s ease;
}

@keyframes gradientText {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.translation {
  display: block;
  font-size: 0.5em;
  margin-top: 0.2em;
  color: #fff;
  text-shadow: 0 0 6px rgba(0,0,0,0.9);
}

/* Центральная панель: поиск и шаг N */
#controls {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 8px;
  z-index: 100;
}

/* Левый нижний угол: словарь + загрузка + Старт/Стоп */
#dictionaryControls {
  position: fixed;
  bottom: 12px;
  left: 12px;
  display: flex;
  gap: 6px;
  z-index: 100;
  color: #fff;
  font-size: 0.85rem;
  align-items: center;
}

#controls input, #controls button,
#dictionaryControls input, #dictionaryControls button {
  background: rgba(0,0,0,0.45);
  border: none;
  border-radius: 14px;
  padding: 10px 14px;
  color: #fff;
  font-size: 1rem;
  outline: none;
  text-align: center;
}

#controls input::placeholder { color: #bbb; }

#controls button:hover,
#dictionaryControls button:hover { background: rgba(0,0,0,0.65); cursor: pointer; }
</style>
</head>

<body>

<!-- Центральная панель -->
<div id="controls">
  <input id="searchInput" placeholder="Слово (DA / RU)">
  <button id="searchBtn">OK</button>
  <input id="stepInput" type="number" min="1" value="1" placeholder="N">
  <button id="stepBtn">OK</button>
</div>

<!-- Левый нижний угол: словарь, загрузка, Старт/Стоп -->
<div id="dictionaryControls">
  <div style="display: flex; gap:4px; align-items: center;">
    <label><input type="radio" name="dict" value="dic.json" checked> Dic</label>
    <label><input type="radio" name="dict" value="word.json"> Word</label>
  </div>

  <label>
    <input type="file" id="localFileInput" accept=".json" style="width:90px">
  </label>

  <button id="startBtn">Старт</button>
  <button id="stopBtn">Стоп</button>
</div>

<script>
const MAX_REPEATS = 5;
let words = [];
let currentIndex = 0;
let stepN = 1;
let nextWordIndex = null;
let showingWord = false;
let sessionRunning = true;

/* ===== TTS ===== */
// Очищаем текст от всех символов кроме букв и пробелов
function cleanTextForTTS(text) {
  return text.replace(/[^a-zA-Zа-яёА-ЯЁæøåÆØÅ\s]/g, '').trim();
}

function speak(text, lang, rate = 1) {
  return new Promise(resolve => {
    const u = new SpeechSynthesisUtterance(cleanTextForTTS(text));
    u.lang = lang;
    u.rate = rate;
    u.onend = resolve;
    speechSynthesis.speak(u);
  });
}

/* ===== POSITION ===== */
function randomPosition(el) {
  const x = Math.random() * (window.innerWidth - el.offsetWidth);
  const y = Math.random() * (window.innerHeight - el.offsetHeight - 80);
  return { x, y };
}
function moveTo(el, pos) { el.style.left = pos.x + 'px'; el.style.top = pos.y + 'px'; }

/* ===== WORD DISPLAY ===== */
async function showWordWithQueue(word) {
  showingWord = true;
  const el = document.createElement('div');
  el.className = 'particle';
  el.innerHTML = `${word.danish}<span class="translation">${word.translation}</span>`;
  document.body.appendChild(el);

  moveTo(el, randomPosition(el));
  await speak(word.translation, 'ru-RU');
  await speak(word.danish, 'da-DK', 0.5);

  const rates = [0.7, 0.9, 1.0];
  for (let i = 1; i < MAX_REPEATS - 1; i++) {
    await new Promise(r => setTimeout(r, 1500));
    moveTo(el, randomPosition(el));
    await speak(word.danish, 'da-DK', rates[Math.min(i - 1, rates.length - 1)]);
  }

  await new Promise(r => setTimeout(r, 1500));
  moveTo(el, randomPosition(el));
  await speak(word.translation, 'ru-RU');
  await speak(word.danish, 'da-DK', 1.0);

  el.remove();
  showingWord = false;

  if (nextWordIndex !== null) {
    const idx = nextWordIndex;
    nextWordIndex = null;
    currentIndex = idx;
    await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== INDEX LOGIC ===== */
function nextIndex() { currentIndex = (currentIndex + stepN) % words.length; }

/* ===== SMART SEARCH ===== */
function findSmartWord(query) {
  query = query.toLowerCase().trim();
  let temp = query;
  while (temp.length > 0) {
    let index = words.findIndex(w =>
      w.danish.toLowerCase() === temp || w.translation.toLowerCase() === temp
    );
    if (index !== -1) return index;
    index = words.findIndex(w =>
      w.danish.toLowerCase().includes(temp) || w.translation.toLowerCase().includes(temp)
    );
    if (index !== -1) return index;
    temp = temp.slice(0, -1);
  }
  return null;
}

/* ===== HANDLE SEARCH ===== */
async function handleSearchImmediate() {
  const query = document.getElementById('searchInput').value.trim();
  document.getElementById('searchInput').value = '';
  if (!query) return;

  const isRussian = /[а-яё]/i.test(query);
  const isPhrase = query.split(/\s+/).length > 1;

  let index = findSmartWord(query);

  if(index === null || isPhrase) {
    const newEntry = isRussian
      ? { danish: '', translation: query }
      : { danish: query, translation: '' };
    words.push(newEntry);
    index = words.length - 1;
  }

  if(showingWord) nextWordIndex = index;
  else {
    currentIndex = index;
    await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== HANDLE STEP ===== */
function handleStep() {
  const val = parseInt(document.getElementById('stepInput').value);
  if(val > 0) stepN = val;
}

/* ===== INPUT EVENTS ===== */
document.getElementById('searchBtn').addEventListener('click', handleSearchImmediate);
document.getElementById('searchInput').addEventListener('keydown', e => { if(e.key === 'Enter') handleSearchImmediate(); });

document.getElementById('stepBtn').addEventListener('click', handleStep);
document.getElementById('stepInput').addEventListener('keydown', e => { if(e.key === 'Enter') handleStep(); });

/* ===== START / STOP ===== */
document.getElementById('startBtn').addEventListener('click', () => { sessionRunning = true; });
document.getElementById('stopBtn').addEventListener('click', () => { sessionRunning = false; });

/* ===== LOCAL FILE LOAD ===== */
document.getElementById('localFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = event => {
    try {
      const data = JSON.parse(event.target.result);
      words = data.map(item => ({ danish: item.word, translation: item.value }));
      currentIndex = 0;
      nextWordIndex = null;
      showingWord = false;
      console.log("Словарь успешно загружен:", file.name);
    } catch(err) {
      console.error("Ошибка при чтении файла:", err);
      alert("Ошибка: неверный формат JSON");
    }
  };
  reader.readAsText(file);
});

/* ===== SERVER DICTIONARY SELECT ===== */
document.querySelectorAll('input[name="dict"]').forEach(radio => {
  radio.addEventListener('change', e => { if(e.target.checked) loadDictionary(e.target.value); });
});

function loadDictionary(file) {
  fetch(file)
    .then(r => r.json())
    .then(data => {
      words = data.map(item => ({ danish: item.word, translation: item.value }));
      currentIndex = 0;
      nextWordIndex = null;
      showingWord = false;
      console.log("Словарь загружен с сервера:", file);
    })
    .catch(err => console.error('Ошибка загрузки словаря:', err));
}

/* ===== START SESSION ===== */
async function startSession() {
  while(true) {
    if(sessionRunning && words.length > 0) {
      await showWordWithQueue(words[currentIndex]);
      nextIndex();
    } else {
      await new Promise(r => setTimeout(r, 500));
    }
  }
}

/* ===== LOAD DEFAULT DICTIONARY ===== */
loadDictionary('dic.json');
startSession();
</script>

</body>
</html>
