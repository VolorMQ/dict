<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flashwords</title>

<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">

<style>
body {
  margin: 0;
  padding: 0;
  font-family: 'Comic Neue', cursive;
  min-height: 100vh;
  overflow: hidden;
  background: linear-gradient(270deg, #1a1a2e, #23233a, #2b2b44, #1f1c2c);
  background-size: 800% 800%;
  animation: gradientBG 70s ease infinite;
}

@keyframes gradientBG {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.particle {
  position: absolute;
  font-weight: bold;
  text-align: center;
  pointer-events: none;
  user-select: none;
  font-size: clamp(2rem, 6vw, 4rem);
  background: linear-gradient(45deg, #ff9a9e, #fad0c4, #ffd700, #6fd6ff, #ff6f61);
  background-size: 400% 400%;
  animation: gradientText 5s ease infinite;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 10px rgba(0,0,0,0.6);
  transition: left 3s ease, top 3s ease;
}

@keyframes gradientText {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.translation {
  display: block;
  font-size: 0.5em;
  margin-top: 0.2em;
  color: #fff;
  text-shadow: 0 0 6px rgba(0,0,0,0.9);
}

#controls {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 8px;
  z-index: 100;
}

#controls input, #controls button {
  background: rgba(0,0,0,0.45);
  border: none;
  border-radius: 14px;
  padding: 10px 14px;
  color: #fff;
  font-size: 1rem;
  outline: none;
  text-align: center;
}

#controls input::placeholder { color: #bbb; }

#controls button {
  cursor: pointer;
  transition: 0.2s;
}

#controls button:hover {
  background: rgba(0,0,0,0.65);
}
</style>
</head>

<body>

<div id="controls">
  <input id="searchInput" placeholder="Слово (DA / RU)">
  <button id="searchBtn">OK</button>
  <input id="stepInput" type="number" min="1" value="1" placeholder="N">
  <button id="stepBtn">OK</button>
</div>

<script>
const MAX_REPEATS = 5;
let words = [];
let currentIndex = 0;
let stepN = 1;
let nextWordIndex = null;
let showingWord = false;

/* ===== TTS ===== */
function speak(text, lang, rate = 1) {
  return new Promise(resolve => {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = lang;
    u.rate = rate;
    u.onend = resolve;
    speechSynthesis.speak(u);
  });
}

/* ===== POSITION ===== */
function randomPosition(el) {
  const x = Math.random() * (window.innerWidth - el.offsetWidth);
  const y = Math.random() * (window.innerHeight - el.offsetHeight - 80);
  return { x, y };
}
function moveTo(el, pos) { el.style.left = pos.x + 'px'; el.style.top = pos.y + 'px'; }

/* ===== WORD DISPLAY ===== */
async function showWordWithQueue(word) {
  showingWord = true;

  const el = document.createElement('div');
  el.className = 'particle';
  el.innerHTML = `${word.danish}<span class="translation">${word.translation}</span>`;
  document.body.appendChild(el);

  moveTo(el, randomPosition(el));

  await speak(word.translation, 'ru-RU');
  await speak(word.danish, 'da-DK', 0.5);

  const rates = [0.7, 0.9, 1.0];
  for (let i = 1; i < MAX_REPEATS - 1; i++) {
    await new Promise(r => setTimeout(r, 1500));
    moveTo(el, randomPosition(el));
    await speak(word.danish, 'da-DK', rates[Math.min(i - 1, rates.length - 1)]);
  }

  await new Promise(r => setTimeout(r, 1500));
  moveTo(el, randomPosition(el));
  await speak(word.translation, 'ru-RU');
  await speak(word.danish, 'da-DK', 1.0);

  el.remove();
  showingWord = false;

  if (nextWordIndex !== null) {
    const idx = nextWordIndex;
    nextWordIndex = null;
    currentIndex = idx;
    await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== INDEX LOGIC ===== */
function nextIndex() { currentIndex = (currentIndex + stepN) % words.length; }

/* ===== SMART SEARCH ===== */
function findSmartWord(query) {
  query = query.toLowerCase().trim();
  let temp = query;
  while (temp.length > 0) {
    let index = words.findIndex(w =>
      w.danish.toLowerCase() === temp || w.translation.toLowerCase() === temp
    );
    if (index !== -1) return index;

    index = words.findIndex(w =>
      w.danish.toLowerCase().includes(temp) || w.translation.toLowerCase().includes(temp)
    );
    if (index !== -1) return index;

    temp = temp.slice(0, -1);
  }
  return null;
}

/* ===== FAKE ONLINE TRANSLATE (двунаправленно) ===== */
async function fakeOnlineTranslate(word) {
  return new Promise(resolve => {
    setTimeout(() => {
      // просто возвращаем слово как перевод без изменений
      // здесь можно потом подключить реальный API
      resolve(word); 
    }, 1200);
  });
}

/* ===== HANDLE SEARCH ===== */
async function handleSearchImmediate() {
  const query = document.getElementById('searchInput').value.trim();
  document.getElementById('searchInput').value = '';
  if (!query) return;

  let index = findSmartWord(query);
  let newEntry = null;

  if(index === null) {
    const isRussian = /[а-яё]/i.test(query);
    const translation = await fakeOnlineTranslate(query);

    if(isRussian) newEntry = { danish: translation, translation: query };
    else newEntry = { danish: query, translation };

    words.push(newEntry);
    index = words.length - 1;
  }

  if(showingWord) nextWordIndex = index;
  else {
    currentIndex = index;
    await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== HANDLE STEP ===== */
function handleStep() {
  const val = parseInt(document.getElementById('stepInput').value);
  if(val > 0) stepN = val;
}

/* ===== INPUT EVENTS ===== */
document.getElementById('searchBtn').addEventListener('click', handleSearchImmediate);
document.getElementById('searchInput').addEventListener('keydown', e => {
  if(e.key === 'Enter') handleSearchImmediate();
});

document.getElementById('stepBtn').addEventListener('click', handleStep);
document.getElementById('stepInput').addEventListener('keydown', e => {
  if(e.key === 'Enter') handleStep();
});

/* ===== SESSION ===== */
async function startSession() {
  while(true) {
    await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== LOAD DICTIONARY ===== */
fetch('dic.json')
  .then(r => r.json())
  .then(data => {
    words = data.map(item => ({ danish: item.word, translation: item.value }));
    startSession();
  })
  .catch(err => console.error('Ошибка загрузки dic.json:', err));
</script>

</body>
</html>
