<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flashwords</title>

<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">

<style>
/* ===== ОСНОВА ===== */
body {
  margin: 0;
  padding: 0;
  font-family: 'Comic Neue', cursive;
  min-height: 100vh;
  overflow: hidden;

  /* ★ расширенная тёмная палитра */
  background: linear-gradient(
    135deg,
    #1a1a2e,
    #2b1b3d,
    #1f2b3a,
    #2e2a1f,
    #1f2c28
  );
  background-size: 900% 900%;

  animation:
    gradientBG 90s linear infinite,
    brightnessPulse 45s ease-in-out infinite;

  position: relative;
}

/* движение по диагонали + по кругу */
@keyframes gradientBG {
  0%   { background-position:   0% 0%; }
  25%  { background-position: 100% 0%; }
  50%  { background-position: 100% 100%; }
  75%  { background-position:   0% 100%; }
  100% { background-position:   0% 0%; }
}

/* мягкая пульсация яркости */
@keyframes brightnessPulse {
  0%   { filter: brightness(0.85); }
  50%  { filter: brightness(1.05); }
  100% { filter: brightness(0.85); }
}

/* мягкий свет / тень */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background: radial-gradient(
    ellipse at 30% 30%,
    rgba(255,255,255,0.1),
    rgba(0,0,0,0.5)
  );
  animation: lightBreath 55s ease-in-out infinite;
  z-index: 0;
}

@keyframes lightBreath {
  0%   { opacity: 0.35; }
  50%  { opacity: 0.5; }
  100% { opacity: 0.35; }
}

/* ===== ЛЕТАЮЩИЕ СЛОВА ===== */
.particle {
  position: absolute;
  font-weight: bold;
  text-align: center;
  pointer-events: none;
  user-select: none;
  font-size: clamp(2rem, 6vw, 4rem);
  background: linear-gradient(45deg, #ff9a9e, #fad0c4, #ffd700, #6fd6ff, #ff6f61);
  background-size: 400% 400%;
  animation: gradientText 5s ease infinite;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 10px rgba(0,0,0,0.6);
  transition: left 3s ease, top 3s ease;
}

@keyframes gradientText {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.translation {
  display: block;
  font-size: 0.5em;
  margin-top: 0.2em;
  color: #fff;
  text-shadow: 0 0 6px rgba(0,0,0,0.9);
}

/* ===== ЦЕНТРАЛЬНЫЕ КОНТРОЛЫ ===== */
#controls {
  position: fixed;
  bottom: 12px; /* теперь внизу */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  flex-wrap: nowrap;
  z-index: 100;
}

/* input + кнопка — всегда вместе */
.input-group {
  display: flex;
  gap: 4px;
  flex-wrap: nowrap;
}

/* Поля ввода */
#controls input {
  background: rgba(0,0,0,0.45);
  border: none;
  border-radius: 12px;
  padding: 8px 10px;
  color: #fff;
  font-size: 1rem;
  outline: none;
  text-align: center;
  width: 140px;
}

/* Кнопки */
#controls button,
#dictionaryControls input,
#dictionaryControls button {
  background: rgba(0,0,0,0.45);
  border: none;
  border-radius: 12px;
  padding: 8px 14px;
  color: #fff;
  font-size: 1rem;
  outline: none;
  text-align: center;
  white-space: nowrap;
}

#controls input::placeholder {
  color: #bbb;
}

#controls button:hover,
#dictionaryControls button:hover {
  background: rgba(0,0,0,0.65);
  cursor: pointer;
}

/* ===== ЛЕВЫЙ НИЖНИЙ БЛОК ===== */
#dictionaryControls {
  position: fixed;
  bottom: 72px; /* сдвинут выше */
  left: 12px;
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
  z-index: 100;
  font-size: 0.85rem;
  color: #fff;
}

/* ===== АДАПТИВНОСТЬ ===== */
@media (max-width: 600px) {
  #controls {
    flex-wrap: wrap;
    justify-content: center;
    bottom: 72px;
  }
  .input-group { width: 100%; justify-content: center; }
  #controls input { width: 120px; }
}

@media (max-width: 420px) {
  #controls input { width: 100px; }
  #controls button,
  #dictionaryControls button,
  #dictionaryControls input {
    padding: 6px 10px;
    font-size: 0.9rem;
  }
}

@media (max-width: 360px) {
  #controls { bottom: 96px; }
  #dictionaryControls { bottom: 12px; left: 6px; gap: 4px; font-size: 0.8rem; }
}

#controls,
#dictionaryControls {
  visibility: hidden; /* скрываем до полной отрисовки */
}
</style>
</head>

<body>

<!-- 1️⃣ Канвас для слов на заднем плане -->
<div id="particleContainer" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>

<!-- 2️⃣ Панели управления поверх канваса -->
<div id="controls">
  <input id="searchInput" placeholder="Слово (DA / RU)">
  <button id="searchBtn">OK</button>
  <input id="stepInput" type="number" min="1" value="1" placeholder="N">
  <button id="stepBtn">OK</button>
</div>

<div id="dictionaryControls">
  <div style="display: flex; gap:4px; align-items: center;">
    <label><input type="radio" name="dict" value="dic.json"> Dic</label>
    <label><input type="radio" name="dict" value="word.json" checked> Word</label>
  </div>
  <label><input type="file" id="localFileInput" accept=".json" style="width:90px"></label>
  <button id="startBtn">Старт</button>
  <button id="stopBtn">Стоп</button>
</div>

<script>
const MAX_REPEATS = 5;
let words = [];
let currentIndex = 0;
let stepN = 1;
let nextWordIndex = null;
let showingWord = false;
let sessionRunning = false;
let sessionStarted = false;

/* ===== TTS с паузой ===== */
const PAUSE_MS_PER_SIGN = 50;

function cleanTextForTTS(text) {
  return text.replace(/[^a-zA-Zа-яёА-ЯЁæøåÆØÅ\s]/g, '').trim();
}

function speak(text, lang, rate = 1) {
  return new Promise(resolve => {
    const u = new SpeechSynthesisUtterance(cleanTextForTTS(text));
    u.lang = lang;
    u.rate = rate;
    u.onend = resolve;
    speechSynthesis.speak(u);
  });
}

async function speakWithPunctuationPauses(originalText, lang, rate = 1) {
  if (!originalText || !originalText.trim()) return;

  const hasPunct = /[^a-zA-Zа-яёА-ЯЁæøåÆØÅ\s]/.test(originalText);
  if (!hasPunct) {
    await speak(originalText, lang, rate);
    return;
  }

  const parts = originalText.match(/([A-Za-zА-Яа-яЁёÆØÅæøå]+(?:\s+[A-Za-zА-Яа-яЁёÆØÅæøå]+)*)|([^A-Za-zА-Яа-яЁёÆØÅæøå\s]+)/g) || [];

  for (const part of parts) {
    if (/[A-Za-zА-Яа-яЁёÆØÅæøå]/.test(part)) {
      await speak(part, lang, rate);
    } else {
      const signsCount = part.replace(/\s/g, '').length;
      if (signsCount > 0) await new Promise(r => setTimeout(r, PAUSE_MS_PER_SIGN * signsCount));
    }
  }
}

/* ===== POSITION ===== */
function randomPosition(el) {
  const topOffset = 12; // минимальный отступ сверху (можно увеличить, если надо)
  const bottomControls = document.getElementById('controls');
  const bottomMenu = document.getElementById('dictionaryControls');

  // вычисляем нижнюю границу для слов: отступ + высота меню
  const bottomLimit = Math.max(bottomControls.offsetHeight, bottomMenu.offsetHeight) + 12; 

  // доступная высота для слов
  const containerHeight = window.innerHeight - el.offsetHeight - bottomLimit - topOffset;

  const x = Math.random() * (window.innerWidth - el.offsetWidth);
  const y = topOffset + Math.random() * containerHeight;

  return { x, y };
}

function moveTo(el, pos) { 
  el.style.left = pos.x + 'px'; 
  el.style.top = pos.y + 'px'; 
}

/* ===== SHOW WORD ===== */
async function showWordWithQueue(word) {
  showingWord = true;
  const el = document.createElement('div');
  el.className = 'particle';
  el.style.position = 'absolute';
  el.innerHTML = `${word.danish}<span class="translation">${word.translation}</span>`;
  document.getElementById('particleContainer').appendChild(el);

  moveTo(el, randomPosition(el));

  // Первый показ
  await speakWithPunctuationPauses(word.translation, 'ru-RU');
  await speakWithPunctuationPauses(word.danish, 'da-DK', 0.3);

  // Повторные показы
  const rates = [0.5, 0.7, 1.0];
  for (let i = 1; i < MAX_REPEATS - 1; i++) {
    await new Promise(r => setTimeout(r, 1500));
    moveTo(el, randomPosition(el));
    await speakWithPunctuationPauses(word.danish, 'da-DK', rates[Math.min(i - 1, rates.length - 1)]);
  }

  // Последний показ
  await new Promise(r => setTimeout(r, 1500));
  moveTo(el, randomPosition(el));
  await speakWithPunctuationPauses(word.translation, 'ru-RU');
  await speakWithPunctuationPauses(word.danish, 'da-DK', 1.0);

  el.remove();
  showingWord = false;

  if (nextWordIndex !== null) {
    const idx = nextWordIndex;
    nextWordIndex = null;
    currentIndex = idx;
    await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== INDEX LOGIC ===== */
function nextIndex() { currentIndex = (currentIndex + stepN) % words.length; }

/* ===== SMART SEARCH ===== */
function findSmartWord(query) {
  query = query.toLowerCase().trim();
  let temp = query;
  while (temp.length > 0) {
    let index = words.findIndex(w =>
      w.danish.toLowerCase() === temp || w.translation.toLowerCase() === temp
    );
    if (index !== -1) return index;
    index = words.findIndex(w =>
      w.danish.toLowerCase().includes(temp) || w.translation.toLowerCase().includes(temp)
    );
    if (index !== -1) return index;
    temp = temp.slice(0, -1);
  }
  return null;
}

/* ===== HANDLE SEARCH ===== */
async function handleSearchImmediate() {
  const query = document.getElementById('searchInput').value.trim();
  document.getElementById('searchInput').value = '';
  if (!query) return;

  const isRussian = /[а-яё]/i.test(query);
  const isPhrase = query.split(/\s+/).length > 1;

  let index = findSmartWord(query);

  if(index === null || isPhrase) {
    const newEntry = isRussian
      ? { danish: '', translation: query }
      : { danish: query, translation: '' };
    words.push(newEntry);
    index = words.length - 1;
  }

  if(showingWord) nextWordIndex = index;
  else {
    currentIndex = index;
    if(sessionRunning) await showWordWithQueue(words[currentIndex]);
    nextIndex();
  }
}

/* ===== HANDLE STEP ===== */
function handleStep() {
  const val = parseInt(document.getElementById('stepInput').value);
  if(val > 0) stepN = val;
}

/* ===== INPUT EVENTS ===== */
document.getElementById('searchBtn').addEventListener('click', handleSearchImmediate);
document.getElementById('searchInput').addEventListener('keydown', e => { if(e.key === 'Enter') handleSearchImmediate(); });

document.getElementById('stepBtn').addEventListener('click', handleStep);
document.getElementById('stepInput').addEventListener('keydown', e => { if(e.key === 'Enter') handleStep(); });

/* ===== START / STOP ===== */
document.getElementById('startBtn').addEventListener('click', () => {
  sessionRunning = true;
  if(!sessionStarted) { sessionStarted = true; startSession(); }
});
document.getElementById('stopBtn').addEventListener('click', () => { sessionRunning = false; });

/* ===== LOCAL FILE LOAD ===== */
document.getElementById('localFileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = event => {
    try {
      const data = JSON.parse(event.target.result);
      words = data.map(item => ({ danish: item.word, translation: item.value }));
      currentIndex = 0;
      nextWordIndex = null;
      showingWord = false;
      console.log("Словарь успешно загружен:", file.name);
    } catch(err) {
      console.error("Ошибка при чтении файла:", err);
      alert("Ошибка: неверный формат JSON");
    }
  };
  reader.readAsText(file);
});

/* ===== SERVER DICTIONARY SELECT ===== */
document.querySelectorAll('input[name="dict"]').forEach(radio => {
  radio.addEventListener('change', e => { if(e.target.checked) loadDictionary(e.target.value); });
});

(function() {
  // Обновляет CSS-переменную --vh (реальная 1vh в px)
  function updateVH() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }

  // Ставит dictionaryControls на базовый отступ, а controls — над ним (без перекрытия)
  function stackControls() {
    const dict = document.getElementById('dictionaryControls');
    const controls = document.getElementById('controls');
    if (!dict || !controls) return;

    const baseBottom = 12; // словарь внизу
    dict.style.bottom = baseBottom + 'px';

    const controlsGap = 12; // отступ сверху словаря
    controls.style.bottom = baseBottom + dict.offsetHeight + controlsGap + 'px';

    controls.style.visibility = 'visible';
    dict.style.visibility = 'visible';
  }

  // Ждём полной загрузки всех шрифтов и рендеринга DOM
  async function refreshAll() {
    updateVH();

    // Ждём шрифты, если они есть
    if (document.fonts && document.fonts.ready) {
      await document.fonts.ready.catch(()=>{/*ignore*/});
    }

    // Ждём следующий frame, чтобы DOM успел перерисоваться
    await new Promise(r => requestAnimationFrame(r));

    // Немного задержки, чтобы учесть финальные размеры (особенно на мобильных)
    setTimeout(stackControls, 50);
  }

  window.addEventListener('load', refreshAll);
  window.addEventListener('resize', refreshAll);
})();

function loadDictionary(file) {
  fetch(file)
    .then(r => r.json())
    .then(data => {
      words = data.map(item => ({ danish: item.word, translation: item.value }));
      currentIndex = 0;
      nextWordIndex = null;
      showingWord = false;
      console.log("Словарь загружен с сервера:", file);
    })
    .catch(err => console.error('Ошибка загрузки словаря:', err));
}

/* ===== START SESSION ===== */
async function startSession() {
  while(true) {
    if(sessionRunning && words.length > 0) {
      await showWordWithQueue(words[currentIndex]);
      nextIndex();
    } else {
      await new Promise(r => setTimeout(r, 500));
    }
  }
}

/* ===== LOAD DEFAULT DICTIONARY ===== */
loadDictionary('word.json'); // теперь по умолчанию word.json

// ==== Показ панелей сразу после загрузки ====
window.addEventListener('load', () => {
  const controls = document.getElementById('controls');
  const dict = document.getElementById('dictionaryControls');

  // форсируем reflow, чтобы браузер сразу корректно отрисовал панели
  controls.offsetHeight;
  dict.offsetHeight;

  controls.style.visibility = 'visible';
  dict.style.visibility = 'visible';
});
</script>

</body>
</html>
